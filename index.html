<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Géocodeur CSV vers GeoJSON</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #status p {
            word-break: break-all;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 flex items-center justify-center min-h-screen">

    <div class="container mx-auto p-4 md:p-8 max-w-2xl">
        <div class="bg-white rounded-xl shadow-lg p-6 md:p-8">
            <div class="text-center mb-6">
                <h1 class="text-2xl md:text-3xl font-bold text-gray-900">Géocodeur d'adresses (CSV vers GeoJSON)</h1>
                <p class="text-gray-600 mt-2">Transformez un fichier CSV d'adresses en coordonnées géographiques au format GeoJSON.</p>
            </div>

            <!-- Instructions -->
            <div class="bg-gray-100 p-4 rounded-lg mb-6 text-sm text-gray-700">
                <h2 class="font-semibold mb-2">Instructions :</h2>
                <ul class="list-disc list-inside space-y-1">
                    <li>Votre fichier CSV doit contenir les colonnes exactes : <code class="bg-gray-200 px-1 rounded">N</code>, <code class="bg-gray-200 px-1 rounded">Bis</code>, <code class="bg-gray-200 px-1 rounded">Suite</code>, <code class="bg-gray-200 px-1 rounded">Rue</code>, <code class="bg-gray-200 px-1 rounded">Code postal</code>, <code class="bg-gray-200 px-1 rounded">Commune</code>, <code class="bg-gray-200 px-1 rounded">Périmètre</code>.</li>
                    <li>Le séparateur peut être une virgule (,) ou un point-virgule (;).</li>
                    <li>Le géocodage utilise Nominatim (OpenStreetMap) puis la Base Adresse Nationale (France) en cas d'échec.</li>
                    <li>Un délai d'une seconde est respecté entre chaque appel pour ne pas surcharger les serveurs.</li>
                </ul>
            </div>
            
            <!-- Zone de téléversement -->
            <div class="space-y-4">
                <div>
                    <label for="csvFile" class="block mb-2 text-sm font-medium text-gray-900">1. Choisissez votre fichier CSV</label>
                    <input type="file" id="csvFile" accept=".csv" class="block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none file:bg-gray-800 file:text-white file:border-0 file:px-4 file:py-2 file:mr-4 file:rounded-l-lg hover:file:bg-gray-700">
                </div>

                <button id="processBtn" class="w-full bg-blue-600 text-white font-bold py-2.5 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition duration-300 disabled:bg-gray-400">
                    2. Lancer le géocodage
                </button>
            </div>
            
            <!-- Zone de résultats et statut -->
            <div id="status" class="mt-6 text-center"></div>

            <!-- Zone d'erreurs -->
            <div id="errors" class="mt-4 hidden">
                <h3 class="font-bold text-red-600">Adresses non trouvées :</h3>
                <ul id="errorList" class="mt-2 list-disc list-inside bg-red-50 text-red-700 p-3 rounded-lg text-sm"></ul>
            </div>

            <!-- Lien de téléchargement -->
            <div id="download" class="mt-6 text-center hidden">
                 <a id="downloadLink" class="inline-block bg-green-600 text-white font-bold py-2.5 px-6 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition duration-300">
                    Télécharger le fichier GeoJSON
                </a>
            </div>
        </div>
        <footer class="text-center mt-4 text-xs text-gray-500">
            <p>Développé avec les API de Nominatim (OpenStreetMap) et de la Base Adresse Nationale.</p>
        </footer>
    </div>

    <script>
        const csvFileInput = document.getElementById('csvFile');
        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');
        const errorsDiv = document.getElementById('errors');
        const errorList = document.getElementById('errorList');
        const downloadDiv = document.getElementById('download');
        const downloadLink = document.getElementById('downloadLink');

        processBtn.addEventListener('click', async () => {
            if (!csvFileInput.files || csvFileInput.files.length === 0) {
                statusDiv.innerHTML = `<p class="text-red-500 font-semibold">Veuillez sélectionner un fichier CSV.</p>`;
                return;
            }

            // Réinitialisation de l'interface
            processBtn.disabled = true;
            statusDiv.innerHTML = '';
            errorsDiv.classList.add('hidden');
            errorList.innerHTML = '';
            downloadDiv.classList.add('hidden');

            const file = csvFileInput.files[0];
            const text = await file.text();
            const rows = parseCSV(text);

            if (rows.length === 0) {
                statusDiv.innerHTML = `<p class="text-red-500 font-semibold">Le fichier CSV est vide ou mal formaté. Aucune ligne de données n'a pu être lue.</p>`;
                processBtn.disabled = false;
                return;
            }

            const geojsonFeatures = [];
            const failedAddresses = [];

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const addressString = [row['N'], row['Bis'], row['Suite'], row['Rue'], row['Code postal'], row['Commune']]
                    .filter(part => part && part.trim() !== '')
                    .join(' ');

                statusDiv.innerHTML = `<p class="text-blue-600">Traitement ${i + 1}/${rows.length}: ${addressString || "Ligne vide..."}</p>`;
                
                const coordinates = await geocodeAddress(addressString);

                if (coordinates) {
                    geojsonFeatures.push({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [coordinates.lon, coordinates.lat]
                        },
                        properties: {
                            // Correction : Accès à la 7ème colonne (index 6) pour 'Périmètre' pour éviter les problèmes d'encodage du nom de la colonne.
                            Perimetre: row[Object.keys(row)[6]] || null,
                            adresse_source: addressString
                        }
                    });
                } else {
                    failedAddresses.push({ line: i + 2, address: addressString }); // +2 pour la ligne d'en-tête et l'index 0
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000)); // Pause pour l'API
            }

            // Finalisation
            statusDiv.innerHTML = `<p class="font-semibold text-green-700">Traitement terminé ! ${geojsonFeatures.length} adresses géocodées, ${failedAddresses.length} échecs.</p>`;
            
            if (failedAddresses.length > 0) {
                errorsDiv.classList.remove('hidden');
                failedAddresses.forEach(err => {
                    const li = document.createElement('li');
                    li.textContent = `Ligne ${err.line}: "${err.address}"`;
                    errorList.appendChild(li);
                });
            }

            if (geojsonFeatures.length > 0) {
                createDownloadLink(geojsonFeatures);
            }
            
            processBtn.disabled = false;
        });

        async function geocodeAddress(address) {
            if (!address || address.trim() === '') {
                console.warn("Tentative de géocodage d'une adresse vide.");
                return null;
            }
            // 1. Essai avec Nominatim
            try {
                const nominatimUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&countrycodes=fr`;
                const response = await fetch(nominatimUrl);
                const data = await response.json();
                if (data && data.length > 0) {
                    console.log(`Nominatim a trouvé: ${address}`);
                    return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
                }
            } catch (error) {
                console.warn("Erreur avec l'API Nominatim :", error);
            }

            // 2. Essai avec l'API BAN (Base Adresse Nationale) en fallback
            try {
                const banUrl = `https://api-adresse.data.gouv.fr/search/?q=${encodeURIComponent(address)}`;
                const response = await fetch(banUrl);
                const data = await response.json();
                if (data && data.features && data.features.length > 0) {
                    console.log(`BAN a trouvé: ${address}`);
                    const coords = data.features[0].geometry.coordinates;
                    return { lat: coords[1], lon: coords[0] };
                }
            } catch (error) {
                console.warn("Erreur avec l'API BAN :", error);
            }

            console.error(`Échec du géocodage pour: ${address}`);
            return null;
        }
        
        /**
         * Analyse une chaîne de caractères CSV et la transforme en un tableau d'objets.
         * Gère les délimiteurs virgule et point-virgule, ainsi que les champs entre guillemets.
         * @param {string} csvText Le contenu brut du fichier CSV.
         * @returns {Array<Object>} Un tableau d'objets représentant les lignes.
         */
        function parseCSV(csvText) {
            const lines = csvText.trim().split(/\r\n|\n/);
            if (lines.length < 2) return [];

            // Détecte le délimiteur à partir de la première ligne (en-tête)
            const delimiter = lines[0].includes(';') ? ';' : ',';
            const headers = lines[0].split(delimiter).map(h => h.trim().replace(/^"|"$/g, ''));
            const rows = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue; // Ignore les lignes vides

                // Sépare la ligne en valeurs, en gérant les guillemets
                const values = [];
                let currentVal = '';
                let inQuotes = false;
                for (const char of line) {
                    if (char === '"' && (currentVal.length === 0 || currentVal[currentVal.length - 1] !== '\\')) {
                        inQuotes = !inQuotes;
                    } else if (char === delimiter && !inQuotes) {
                        values.push(currentVal.replace(/^"|"$/g, '').trim());
                        currentVal = '';
                    } else {
                        currentVal += char;
                    }
                }
                values.push(currentVal.replace(/^"|"$/g, '').trim());
                
                if (values.length < headers.length) {
                    console.warn(`Ligne ${i + 1} ignorée (nombre de colonnes incorrect): ${line}`);
                    continue;
                }

                const rowObject = {};
                for (let j = 0; j < headers.length; j++) {
                    rowObject[headers[j]] = values[j] || '';
                }
                rows.push(rowObject);
            }
            return rows;
        }


        function createDownloadLink(features) {
            const geojson = {
                type: 'FeatureCollection',
                features: features
            };

            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(geojson, null, 2));
            downloadLink.setAttribute("href", dataStr);
            downloadLink.setAttribute("download", "adresses_geocodes.geojson");
            downloadDiv.classList.remove('hidden');
        }

    </script>
</body>
</html>

